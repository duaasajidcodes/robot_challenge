name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  COVERAGE: true

jobs:
  test:
    runs-on: ubuntu-latest
    
    env:
      REDIS_URL: redis://localhost:6379
      REDIS_AVAILABLE: true
      ROBOT_CACHE_DEBUG: true
    
    services:
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    strategy:
      matrix:
        ruby-version: ['3.3.0']
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Ruby ${{ matrix.ruby-version }}
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: ${{ matrix.ruby-version }}
        bundler-cache: true
    
    - name: Install dependencies
      run: |
        echo "=== Installing dependencies ==="
        bundle install --jobs 4 --retry 3
        echo "=== Dependencies installed ==="
        
        # Verify Redis gem is available
        if ! bundle exec ruby -e "require 'redis'; puts 'Redis gem available'"; then
          echo "Redis gem not available, clearing cache and reinstalling..."
          bundle clean --force
          bundle install --jobs 4 --retry 3
        fi
    
    - name: Check Redis service status
      run: |
        # Install net-tools for netstat command
        sudo apt-get update && sudo apt-get install -y net-tools
        
        echo "=== Redis Service Status ==="
        docker ps | grep redis || echo "No Redis container found"
        echo ""
        echo "=== Network connectivity ==="
        netstat -tlnp | grep 6379 || echo "No process listening on port 6379"
        echo ""
        echo "=== Environment variables ==="
        echo "REDIS_URL: ${REDIS_URL:-'not set'}"
        echo "REDIS_AVAILABLE: ${REDIS_AVAILABLE:-'not set'}"
    
    - name: Wait for Redis
      run: |
        # Use Ruby to check Redis connectivity (more reliable than CLI tools)
        ruby -e "
          require 'socket'
          require 'timeout'
          
          puts 'Checking Redis connectivity...'
          
          begin
            Timeout.timeout(30) do
              loop do
                begin
                  socket = TCPSocket.new('localhost', 6379)
                  socket.close
                  puts 'Redis is accessible on port 6379'
                  break
                rescue => e
                  puts \"Waiting for Redis... (#{e.message})\"
                  sleep 1
                end
              end
            end
          rescue Timeout::Error
            puts 'Timeout waiting for Redis'
            exit 1
          end
        "
    
    - name: Verify gems are installed
      run: |
        echo "=== Checking installed gems ==="
        bundle list | grep redis || echo "Redis gem not found in bundle"
        echo ""
        echo "=== Checking Ruby environment ==="
        bundle exec ruby -e "puts 'Ruby version: ' + RUBY_VERSION"
        bundle exec ruby -e "puts 'Gem path: ' + Gem.path.join(', ')"
        echo ""
        echo "=== Testing gem loading ==="
        bundle exec ruby -e "require 'redis'; puts 'Redis gem loaded successfully'" || echo "Failed to load Redis gem"
    
    - name: Verify Redis functionality
      run: |
        # Test Redis functionality with proper error handling
        echo "Testing Redis functionality..."
        
        # Test with bundle exec to ensure gems are loaded
        if bundle exec ruby -e "
          require 'redis'
          
          begin
            puts 'Testing Redis connection...'
            redis = Redis.new(url: 'redis://localhost:6379')
            response = redis.ping
            puts \"Redis ping response: #{response}\"
            
            # Test basic operations
            redis.set('test_key', 'test_value')
            value = redis.get('test_key')
            puts \"Redis test: #{value}\"
            
            redis.del('test_key')
            puts 'Redis functionality verified successfully'
            
            # Show Redis info
            info = redis.info
            puts \"Redis version: #{info['redis_version']}\"
            puts \"Redis memory: #{info['used_memory_human']}\"
          rescue => e
            puts \"Redis functionality test failed: #{e.message}\"
            puts \"Error class: #{e.class}\"
            exit 1
          end
        "; then
          echo "Redis functionality test passed"
        else
          echo "Redis functionality test failed, but continuing with tests"
          echo "Tests will use mock Redis if needed"
        fi
    
    - name: Test application startup
      run: |
        echo "Testing application startup with Redis fallback..."
        bundle exec ruby -e "
          require_relative 'lib/robot_challenge'
          
          begin
            # Test that the application can start
            app = RobotChallenge::Application.new
            puts 'Application started successfully'
            
            # Test cache creation
            cache = RobotChallenge::Cache.create_redis_cache
            puts 'Cache created successfully'
            
            # Test basic cache operations
            cache.cache_robot_state('test', {test: 'data'})
            result = cache.get_robot_state('test')
            puts \"Cache test result: #{result}\"
            
            puts 'Application and cache tests passed'
          rescue => e
            puts \"Application test failed: #{e.message}\"
            puts \"Error class: #{e.class}\"
            exit 1
          end
        "
    
    - name: Run linting
      run: bundle exec rubocop --fail-level=error
    
    - name: Run tests
      run: bundle exec rspec --format progress
    
    - name: Generate coverage report
      if: success()
      run: |
        if [ -f coverage/.resultset.json ]; then
          echo "Coverage report generated"
        fi

  docker:
    runs-on: ubuntu-latest
    needs: test
    steps:
    - uses: actions/checkout@v4
    
    - name: Build Docker image
      run: docker build -t robot-challenge .
    
    - name: Test Docker image - Example 1
      run: |
        echo -e "PLACE 0,0,NORTH\nMOVE\nREPORT" | docker run -i robot-challenge | grep "0,1,NORTH"
    
    - name: Test Docker image - Example 2  
      run: |
        echo -e "PLACE 0,0,NORTH\nLEFT\nREPORT" | docker run -i robot-challenge | grep "0,0,WEST"
        
    - name: Test Docker image - Example 3
      run: |
        echo -e "PLACE 1,2,EAST\nMOVE\nMOVE\nLEFT\nMOVE\nREPORT" | docker run -i robot-challenge | grep "3,3,NORTH"

  lint:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.3.0'
        bundler-cache: true
    
    - name: Run RuboCop
      run: bundle exec rubocop --fail-level=error --display-only-fail-level-offenses
